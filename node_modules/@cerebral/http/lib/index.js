'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HttpProviderError = undefined;

var _HttpProviderError = require('./HttpProviderError');

Object.defineProperty(exports, 'HttpProviderError', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_HttpProviderError).default;
  }
});
exports.default = HttpProviderFactory;

var _request = require('./request');

var _request2 = _interopRequireDefault(_request);

var _utils = require('./utils');

var _fileUpload = require('./fileUpload');

var _fileUpload2 = _interopRequireDefault(_fileUpload);

var _DEFAULT_OPTIONS = require('./DEFAULT_OPTIONS');

var _DEFAULT_OPTIONS2 = _interopRequireDefault(_DEFAULT_OPTIONS);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function HttpProviderFactory(passedOptions) {
  var moduleOptions = (0, _utils.mergeWith)({}, _DEFAULT_OPTIONS2.default);
  if (typeof passedOptions === 'function') {
    moduleOptions = passedOptions(moduleOptions);
  } else if (passedOptions) {
    moduleOptions = (0, _utils.mergeWith)(passedOptions, _DEFAULT_OPTIONS2.default);
  }

  var cachedProvider = null;
  function HttpProvider(context) {
    var requests = {};
    function createAbortablePromise(url, cb) {
      return new Promise(function (resolve, reject) {
        requests[url] = {
          resolve: resolve,
          reject: reject,
          // eslint-disable-next-line standard/no-callback-literal
          xhr: cb(function (payload) {
            delete requests[url];
            resolve(payload);
          }, function (error) {
            delete requests[url];
            reject(error);
          })
        };
      });
    }

    function requestService(options) {
      options = (0, _utils.mergeWith)(options, moduleOptions);

      if (typeof options.onProgress === 'string') {
        options.onProgress = context.controller.getSignal(options.onProgress);
      }

      options.method = options.method.toUpperCase();

      return createAbortablePromise(options.url, function (resolve, reject) {
        return (0, _request2.default)(options, (0, _utils.createResponse)(options, resolve, reject));
      });
    }

    if (cachedProvider) {
      context.http = cachedProvider;
    } else {
      context.http = cachedProvider = {
        request: requestService,
        get: function get(url, passedQuery) {
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

          var query = passedQuery || options.query;

          options.url = query && Object.keys(query).length ? url + '?' + (0, _utils.urlEncode)(query) : url;
          options.method = 'GET';

          return requestService(options);
        },
        post: function post(url, body) {
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

          options.url = options.query && Object.keys(options.query).length ? url + '?' + (0, _utils.urlEncode)(options.query) : url;
          options.method = 'POST';
          options.body = body;

          return requestService(options);
        },
        put: function put(url, body) {
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

          options.url = options.query && Object.keys(options.query).length ? url + '?' + (0, _utils.urlEncode)(options.query) : url;
          options.method = 'PUT';
          options.body = body;

          return requestService(options);
        },
        patch: function patch(url, body) {
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

          options.url = options.query && Object.keys(options.query).length ? url + '?' + (0, _utils.urlEncode)(options.query) : url;
          options.method = 'PATCH';
          options.body = body;

          return requestService(options);
        },
        delete: function _delete(url, query) {
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

          options.url = options.query && Object.keys(options.query).length ? url + '?' + (0, _utils.urlEncode)(options.query) : url;
          options.method = 'DELETE';

          return requestService(options);
        },
        updateOptions: function updateOptions(newOptions) {
          moduleOptions = (0, _utils.mergeWith)(newOptions, moduleOptions);
        },
        abort: function abort(regexp) {
          var matchingUrls = Object.keys(requests).filter(function (url) {
            return Boolean(url.match(new RegExp(regexp)));
          });
          matchingUrls.forEach(function (url) {
            requests[url].xhr.abort();
          });
        },
        uploadFile: function uploadFile(url, files) {
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

          options.url = moduleOptions.baseUrl + url;

          return new _fileUpload2.default(options).send(files);
        }
      };
    }

    if (context.debugger) {
      context.debugger.wrapProvider('http');
    }

    return context;
  }
  return HttpProvider;
}
//# sourceMappingURL=index.js.map