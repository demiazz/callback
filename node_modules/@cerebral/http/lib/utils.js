'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.createResponse = createResponse;
exports.mergeWith = mergeWith;
exports.urlEncode = urlEncode;
exports.convertObjectWithTemplates = convertObjectWithTemplates;
exports.parseHeaders = parseHeaders;
exports.processResponse = processResponse;
exports.getAllResponseHeaders = getAllResponseHeaders;

var _HttpProviderError = require('./HttpProviderError');

var _HttpProviderError2 = _interopRequireDefault(_HttpProviderError);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function createResponse(options, resolve, reject) {
  return function (event) {
    switch (event.type) {
      case 'load':
        return options.onResponse(event.currentTarget, resolve, reject);
      case 'progress':
        if (options.onProgress && event.lengthComputable) {
          options.onProgress({
            progress: Number(event.loaded / event.total).toFixed(0)
          });
        }
        break;
      case 'error':
        reject(new _HttpProviderError2.default(event.currentTarget.status, null, null, 'request error'));
        break;
      case 'abort':
        reject(new _HttpProviderError2.default(event.currentTarget.status, null, null, 'request abort', true));
        break;
    }
  };
}

function mergeWith(optionsA, optionsB) {
  return Object.keys(optionsB).reduce(function (newOptions, key) {
    if (!newOptions[key]) {
      newOptions[key] = optionsB[key];
    } else if (key === 'headers') {
      newOptions[key] = mergeWith(newOptions[key], optionsB[key] || {});
    }

    return newOptions;
  }, optionsA);
}

function urlEncode(obj, prefix) {
  var str = [];

  for (var p in obj) {
    if (obj.hasOwnProperty(p)) {
      var k = prefix ? prefix + '[' + p + ']' : p;
      var v = obj[p];

      str.push((typeof v === 'undefined' ? 'undefined' : _typeof(v)) === 'object' ? urlEncode(v, k) : encodeURIComponent(k) + '=' + encodeURIComponent(v));
    }
  }
  return str.join('&');
}

function convertObjectWithTemplates(obj, resolve) {
  if (resolve.isTag(obj)) {
    return resolve.value(obj);
  }

  return Object.keys(obj).reduce(function (convertedObject, key) {
    convertedObject[key] = resolve.value(obj[key]);
    return convertedObject;
  }, {});
}

function parseHeaders(rawHeaders) {
  var headerPairs = rawHeaders.replace(/\r?\n$/, '').split(/\r?\n/);

  return headerPairs.reduce(function (parsedHeaders, headerPair) {
    var index = headerPair.indexOf(':');
    var key = headerPair.substr(0, index).trim().toLowerCase();
    var value = headerPair.substr(index + 1).trim();
    if (key) {
      parsedHeaders[key] = parsedHeaders[key] ? parsedHeaders[key] + ', ' + value : value;
    }

    return parsedHeaders;
  }, {});
}

function processResponse(httpAction, path) {
  return httpAction.then(function (response) {
    if (path && path[response.status]) {
      return path[response.status](response);
    }

    return path && path.success ? path.success(response) : response;
  })
  // This error will be an instance of HttpError
  .catch(function (error) {
    if (!path) {
      throw error;
    }

    if (error.isAborted && path.abort) {
      return path.abort({ error: error.toJSON() });
    }

    if (path[error.status]) {
      return path[error.status]({ error: error.toJSON() });
    }

    if (path.error) {
      return path.error({ error: error.toJSON() });
    }

    throw error;
  });
}

function getAllResponseHeaders(xhr) {
  return 'getAllResponseHeaders' in xhr ? parseHeaders(xhr.getAllResponseHeaders()) : null;
}
//# sourceMappingURL=utils.js.map