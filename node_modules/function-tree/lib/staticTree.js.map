{"version":3,"sources":["../src/staticTree.js"],"names":["getFunctionName","fn","ret","toString","substr","length","indexOf","isPaths","item","Array","isArray","analyze","functions","isParallel","instance","toJSON","Object","assign","items","reduce","allItems","subItem","index","concat","funcDetails","name","displayName","functionIndex","push","function","nextItem","outputs","keys","forEach","key","tree"],"mappings":"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","file":"staticTree.js","sourcesContent":["import { Sequence, Parallel, Primitive } from './primitives'\nimport { FunctionTreeError } from './errors'\n\nfunction getFunctionName(fn) {\n  let ret = fn.toString()\n  ret = ret.substr('function '.length)\n  ret = ret.substr(0, ret.indexOf('('))\n\n  return ret\n}\n\nfunction isPaths(item) {\n  return (\n    item &&\n    !Array.isArray(item) &&\n    typeof item === 'object' &&\n    !(item instanceof Primitive)\n  )\n}\n\nfunction analyze(functions, item, isParallel) {\n  if (item instanceof Primitive) {\n    const instance = item.toJSON()\n\n    return Object.assign(instance, {\n      items: analyze(functions, instance.items, item instanceof Parallel).items,\n    })\n  } else if (Array.isArray(item)) {\n    return new Sequence(\n      item.reduce((allItems, subItem, index) => {\n        if (subItem instanceof Primitive) {\n          const instance = subItem.toJSON()\n\n          return allItems.concat(\n            Object.assign(instance, {\n              items: analyze(\n                functions,\n                instance.items,\n                subItem instanceof Parallel\n              ).items,\n            })\n          )\n        } else if (typeof subItem === 'function') {\n          const funcDetails = {\n            name: subItem.displayName || getFunctionName(subItem),\n            functionIndex: functions.push(subItem) - 1,\n            function: subItem,\n          }\n          const nextItem = item[index + 1]\n\n          if (isPaths(nextItem)) {\n            funcDetails.outputs = {}\n            Object.keys(nextItem).forEach(key => {\n              if (subItem.outputs && !~subItem.outputs.indexOf(key)) {\n                throw new FunctionTreeError(\n                  `Outputs object doesn't match list of possible outputs defined for function.`\n                )\n              }\n              funcDetails.outputs[key] = analyze(\n                functions,\n                typeof nextItem[key] === 'function'\n                  ? [nextItem[key]]\n                  : nextItem[key]\n              )\n            })\n          }\n\n          return allItems.concat(funcDetails)\n        } else if (isPaths(subItem)) {\n          return allItems\n        } else if (Array.isArray(subItem)) {\n          const items = analyze(functions, subItem)\n\n          return allItems.concat(items)\n        } else {\n          throw new FunctionTreeError('Unexpected entry in tree')\n        }\n      }, [])\n    ).toJSON()\n  } else {\n    throw new FunctionTreeError('Unexpected entry in tree')\n  }\n}\n\nexport default tree => {\n  const functions = []\n\n  return analyze(functions, typeof tree === 'function' ? [tree] : tree)\n}\n"]}