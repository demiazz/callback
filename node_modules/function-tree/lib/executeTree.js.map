{"version":3,"sources":["../src/executeTree.js"],"names":["executeTree","isPrimitive","primitive","type","_functionTreePrimitive","execution","initialPayload","branchStart","branchEnd","parallelStart","parallelProgress","parallelEnd","end","runBranch","branch","index","payload","prevPayload","nextBranch","runNextItem","result","processFunctionOutput","funcDetails","outputResult","newPayload","Object","assign","outputs","keys","indexOf","path","items","name","join","currentItem","staticTree","itemLength","length","payloads","forEach","func","function","runFunction","push","apply","concat"],"mappings":"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","file":"executeTree.js","sourcesContent":["import { FunctionTreeExecutionError } from './errors'\n\nfunction isPrimitive(primitive, type) {\n  return primitive._functionTreePrimitive && primitive.type === type\n}\n\n/*\n  Runs through the tree providing a \"next\" callback to process next step\n  of execution\n*/\nexport default function executeTree(\n  execution,\n  initialPayload,\n  branchStart,\n  branchEnd,\n  parallelStart,\n  parallelProgress,\n  parallelEnd,\n  end\n) {\n  function runBranch(branch, index, payload, prevPayload, nextBranch) {\n    function runNextItem(result) {\n      runBranch(branch, index + 1, result, payload, nextBranch)\n    }\n\n    function processFunctionOutput(funcDetails, outputResult) {\n      return function(result) {\n        const newPayload = Object.assign(\n          {},\n          payload,\n          result ? result.payload : {}\n        )\n\n        if (result && funcDetails.outputs) {\n          const outputs = Object.keys(funcDetails.outputs)\n\n          if (~outputs.indexOf(result.path)) {\n            branchStart(funcDetails, result.path, newPayload)\n            runBranch(\n              funcDetails.outputs[result.path].items,\n              0,\n              newPayload,\n              payload,\n              outputResult\n            )\n          } else {\n            throw new FunctionTreeExecutionError(\n              execution,\n              funcDetails,\n              payload,\n              `function ${funcDetails.name} must use one of its possible outputs: ${outputs.join(', ')}.`\n            )\n          }\n        } else {\n          outputResult(newPayload)\n        }\n      }\n    }\n\n    const currentItem = branch[index]\n\n    if (!currentItem) {\n      if (branch !== execution.staticTree) {\n        branchEnd(payload)\n      }\n      nextBranch(payload)\n    } else if (isPrimitive(currentItem, 'sequence')) {\n      runBranch(currentItem.items, 0, payload, prevPayload, runNextItem)\n    } else if (isPrimitive(currentItem, 'parallel')) {\n      const itemLength = currentItem.items.length\n      const payloads = []\n\n      parallelStart(payload, itemLength)\n      currentItem.items.forEach((func, index) => {\n        if (func.function) {\n          execution.runFunction(\n            func,\n            payload,\n            prevPayload,\n            processFunctionOutput(func, payload => {\n              payloads.push(payload)\n              if (payloads.length === itemLength) {\n                parallelEnd(payload, itemLength)\n                runNextItem(Object.assign.apply(Object, [{}].concat(payloads)))\n              } else {\n                parallelProgress(payload, itemLength - payloads.length)\n              }\n            })\n          )\n        } else {\n          runBranch(func.items, 0, payload, prevPayload, function(payload) {\n            payloads.push(payload)\n            if (payloads.length === itemLength) {\n              parallelEnd(payload, itemLength)\n              runNextItem(Object.assign.apply(Object, [{}].concat(payloads)))\n            } else {\n              parallelProgress(payload, itemLength - payloads.length)\n            }\n          })\n        }\n\n        return payloads\n      })\n    } else {\n      execution.runFunction(\n        currentItem,\n        payload,\n        prevPayload,\n        processFunctionOutput(currentItem, runNextItem)\n      )\n    }\n  }\n\n  return runBranch([execution.staticTree], 0, initialPayload, null, end)\n}\n"]}