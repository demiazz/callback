'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FunctionTree = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _eventemitter = require('eventemitter3');

var _eventemitter2 = _interopRequireDefault(_eventemitter);

var _executeTree = require('./executeTree');

var _executeTree2 = _interopRequireDefault(_executeTree);

var _staticTree = require('./staticTree');

var _staticTree2 = _interopRequireDefault(_staticTree);

var _Execution = require('./providers/Execution');

var _Execution2 = _interopRequireDefault(_Execution);

var _Context = require('./providers/Context');

var _Context2 = _interopRequireDefault(_Context);

var _Props = require('./providers/Props');

var _Props2 = _interopRequireDefault(_Props);

var _Path = require('./providers/Path');

var _Path2 = _interopRequireDefault(_Path);

var _Path3 = require('./Path');

var _Path4 = _interopRequireDefault(_Path3);

var _primitives = require('./primitives');

var _errors = require('./errors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
  Need to create a unique ID for each execution to identify it
  in debugger
*/
function createUniqueId() {
  return Date.now() + '_' + Math.floor(Math.random() * 10000);
}

/*
  Validate any returned value from a function. Has
  to be nothing or an object
*/
function isValidResult(result) {
  return !result || (typeof result === 'undefined' ? 'undefined' : _typeof(result)) === 'object' && !Array.isArray(result);
}

/*
  Create an error with execution details
*/
function createErrorObject(error, execution, functionDetails, payload) {
  var errorToReturn = error;

  errorToReturn.execution = execution;
  errorToReturn.functionDetails = functionDetails;
  errorToReturn.payload = Object.assign({}, payload, {
    _execution: {
      id: execution.id,
      functionIndex: functionDetails.functionIndex
    },
    error: error.toJSON ? error.toJSON() : {
      name: error.name,
      message: error.message,
      stack: error.stack
    }
  });

  return errorToReturn;
}

/*
  If it walks like a duck and quacks like a duck...
*/
function isPromise(result) {
  return result && typeof result.then === 'function' && typeof result.catch === 'function';
}

var FunctionTreeExecution = function () {
  function FunctionTreeExecution(name, staticTree, functionTree, errorCallback) {
    _classCallCheck(this, FunctionTreeExecution);

    this.id = createUniqueId();
    this.name = name || staticTree.name || this.id;
    this.staticTree = staticTree;
    this.functionTree = functionTree;
    this.datetime = Date.now();
    this.errorCallback = errorCallback;
    this.hasThrown = false;

    this.runFunction = this.runFunction.bind(this);
  }

  /*
    Creates the context for the current function to be run,
    emits events and handles its returned value. Also handles
    the returned value being a promise
  */


  _createClass(FunctionTreeExecution, [{
    key: 'runFunction',
    value: function runFunction(funcDetails, payload, prevPayload, next) {
      if (this.hasThrown) {
        return;
      }

      var context = this.createContext(funcDetails, payload, prevPayload);
      var functionTree = this.functionTree;
      var errorCallback = this.errorCallback;
      var execution = this;
      var result = void 0;

      functionTree.emit('functionStart', execution, funcDetails, payload);
      try {
        result = funcDetails.function(context);
      } catch (error) {
        this.hasThrown = true;

        return errorCallback(createErrorObject(error, execution, funcDetails, payload), execution, funcDetails, payload);
      }

      /*
        If result is a promise we want to emit an event and wait for it to resolve to
        move on
      */
      if (isPromise(result)) {
        functionTree.emit('asyncFunction', execution, funcDetails, payload, result);
        result.then(function (result) {
          if (result instanceof _Path4.default) {
            functionTree.emit('functionEnd', execution, funcDetails, payload, result);
            next(result.toJSON());
          } else if (funcDetails.outputs) {
            functionTree.emit('functionEnd', execution, funcDetails, payload, result);
            throw new _errors.FunctionTreeExecutionError(execution, funcDetails, payload, new Error('The result ' + JSON.stringify(result) + ' from function ' + funcDetails.name + ' needs to be a path of either ' + Object.keys(funcDetails.outputs)));
          } else if (isValidResult(result)) {
            functionTree.emit('functionEnd', execution, funcDetails, payload, result);
            next({
              payload: result
            });
          } else {
            functionTree.emit('functionEnd', execution, funcDetails, payload, result);
            throw new _errors.FunctionTreeExecutionError(execution, funcDetails, payload, new Error('The result ' + JSON.stringify(result) + ' from function ' + funcDetails.name + ' is not a valid result'));
          }
        }).catch(function (result) {
          if (result instanceof Error) {
            execution.hasThrown = true;
            errorCallback(createErrorObject(result, execution, funcDetails, payload), execution, funcDetails, payload);
          } else if (result instanceof _Path4.default) {
            functionTree.emit('functionEnd', execution, funcDetails, payload, result);
            next(result.toJSON());
          } else if (funcDetails.outputs) {
            var error = new _errors.FunctionTreeExecutionError(execution, funcDetails, payload, new Error('The result ' + JSON.stringify(result) + ' from function ' + funcDetails.name + ' needs to be a path of either ' + Object.keys(funcDetails.outputs)));

            execution.hasThrown = true;
            errorCallback(createErrorObject(error, execution, funcDetails, payload), execution, funcDetails, payload);
          } else if (isValidResult(result)) {
            functionTree.emit('functionEnd', execution, funcDetails, payload, result);
            next({
              payload: result
            });
          } else {
            var _error = new _errors.FunctionTreeExecutionError(execution, funcDetails, payload, new Error('The result ' + JSON.stringify(result) + ' from function ' + funcDetails.name + ' is not a valid result'));
            execution.hasThrown = true;

            errorCallback(createErrorObject(_error, execution, funcDetails, payload), execution, funcDetails, payload);
          }
        });
      } else if (result instanceof _Path4.default) {
        functionTree.emit('functionEnd', execution, funcDetails, payload, result);
        next(result.toJSON());
      } else if (funcDetails.outputs) {
        var error = new _errors.FunctionTreeExecutionError(execution, funcDetails, payload, new Error('The result ' + JSON.stringify(result) + ' from function ' + funcDetails.name + ' needs to be a path of either ' + Object.keys(funcDetails.outputs)));

        this.hasThrown = true;
        errorCallback(createErrorObject(error, execution, funcDetails, payload), execution, funcDetails, payload);
      } else if (isValidResult(result)) {
        functionTree.emit('functionEnd', execution, funcDetails, payload, result);
        next({
          payload: result
        });
      } else {
        var _error2 = new _errors.FunctionTreeExecutionError(execution, funcDetails, payload, new Error('The result ' + JSON.stringify(result) + ' from function ' + funcDetails.name + ' is not a valid result'));
        this.hasThrown = true;

        errorCallback(createErrorObject(_error2, execution, funcDetails, payload), execution, funcDetails, payload);
      }
    }

    /*
      Creates the context for the next running function
    */

  }, {
    key: 'createContext',
    value: function createContext(funcDetails, payload, prevPayload) {
      return [(0, _Execution2.default)(this), (0, _Props2.default)(), (0, _Path2.default)()].concat(this.functionTree.contextProviders).reduce(function (currentContext, contextProvider) {
        var newContext = typeof contextProvider === 'function' ? contextProvider(currentContext, funcDetails, payload, prevPayload) : (0, _Context2.default)(contextProvider)(currentContext, funcDetails, payload, prevPayload);

        if (newContext !== currentContext) {
          throw new _errors.FunctionTreeError('A provider is not returning the context object, maybe it is a function factory and you forgot to call it?');
        }

        return newContext;
      }, {});
    }
  }]);

  return FunctionTreeExecution;
}();

var FunctionTree = exports.FunctionTree = function (_EventEmitter) {
  _inherits(FunctionTree, _EventEmitter);

  function FunctionTree(contextProviders) {
    _classCallCheck(this, FunctionTree);

    var _this = _possibleConstructorReturn(this, (FunctionTree.__proto__ || Object.getPrototypeOf(FunctionTree)).call(this));

    _this.cachedTrees = [];
    _this.cachedStaticTrees = [];
    if (Array.isArray(contextProviders)) {
      _this.contextProviders = contextProviders;
    } else if (contextProviders) {
      _this.contextProviders = [(0, _Context2.default)(contextProviders)];
    } else {
      _this.contextProviders = [];
    }

    _this.run = _this.run.bind(_this);
    return _this;
  }

  /*
    Analyses the tree to identify paths and its validity. This analysis
    is cached. Then the method creates an execution for the tree to run.
  */


  _createClass(FunctionTree, [{
    key: 'run',
    value: function run() {
      var _this2 = this;

      var name = void 0;
      var tree = void 0;
      var payload = void 0;
      var cb = void 0;
      var staticTree = void 0;
      var args = [].slice.call(arguments);
      args.forEach(function (arg) {
        if (typeof arg === 'string') {
          name = arg;
        } else if (Array.isArray(arg) || arg instanceof _primitives.Primitive) {
          tree = arg;
        } else if (!tree && typeof arg === 'function') {
          tree = arg;
        } else if (typeof arg === 'function') {
          cb = arg;
        } else {
          payload = arg;
        }
      });

      if (!tree) {
        throw new Error('function-tree - You did not pass in a function tree');
      }

      var withResolveAndReject = function withResolveAndReject(resolve, reject) {
        var treeIdx = _this2.cachedTrees.indexOf(tree);
        if (treeIdx === -1) {
          staticTree = (0, _staticTree2.default)(tree);
          _this2.cachedTrees.push(tree);
          _this2.cachedStaticTrees.push(staticTree);
        } else {
          staticTree = _this2.cachedStaticTrees[treeIdx];
        }
        var execution = new FunctionTreeExecution(name, staticTree, _this2, function (error, execution, funcDetails, finalPayload) {
          _this2.emit('error', error, execution, funcDetails, finalPayload);
          reject(error);
        });

        _this2.emit('start', execution, payload);
        (0, _executeTree2.default)(execution, payload, function (funcDetails, path, currentPayload) {
          _this2.emit('pathStart', path, execution, funcDetails, currentPayload);
        }, function (currentPayload) {
          _this2.emit('pathEnd', execution, currentPayload);
        }, function (currentPayload, functionsToResolve) {
          _this2.emit('parallelStart', execution, currentPayload, functionsToResolve);
        }, function (currentPayload, functionsResolved) {
          _this2.emit('parallelProgress', execution, currentPayload, functionsResolved);
        }, function (currentPayload, functionsResolved) {
          _this2.emit('parallelEnd', execution, currentPayload, functionsResolved);
        }, function (finalPayload) {
          _this2.emit('end', execution, finalPayload);
          resolve === reject ? resolve(null, finalPayload) : resolve(finalPayload);
        });
      };

      if (cb) {
        withResolveAndReject(cb, cb);
      } else {
        return new Promise(withResolveAndReject);
      }
    }
  }]);

  return FunctionTree;
}(_eventemitter2.default);
//# sourceMappingURL=FunctionTree.js.map