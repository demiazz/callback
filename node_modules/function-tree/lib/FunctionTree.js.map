{"version":3,"sources":["../src/FunctionTree.js"],"names":["createUniqueId","Date","now","Math","floor","random","isValidResult","result","Array","isArray","createErrorObject","error","execution","functionDetails","payload","errorToReturn","Object","assign","_execution","id","functionIndex","toJSON","name","message","stack","isPromise","then","catch","FunctionTreeExecution","staticTree","functionTree","errorCallback","datetime","hasThrown","runFunction","bind","funcDetails","prevPayload","next","context","createContext","emit","function","outputs","Error","JSON","stringify","keys","concat","contextProviders","reduce","currentContext","contextProvider","newContext","FunctionTree","cachedTrees","cachedStaticTrees","run","tree","cb","args","slice","call","arguments","forEach","arg","withResolveAndReject","resolve","reject","treeIdx","indexOf","push","finalPayload","path","currentPayload","functionsToResolve","functionsResolved","Promise"],"mappings":"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","file":"FunctionTree.js","sourcesContent":["import EventEmitter from 'eventemitter3'\nimport executeTree from './executeTree'\nimport createStaticTree from './staticTree'\nimport ExecutionProvider from './providers/Execution'\nimport ContextProvider from './providers/Context'\nimport PropsProvider from './providers/Props'\nimport PathProvider from './providers/Path'\nimport Path from './Path'\nimport { Primitive } from './primitives'\nimport { FunctionTreeExecutionError, FunctionTreeError } from './errors'\n\n/*\n  Need to create a unique ID for each execution to identify it\n  in debugger\n*/\nfunction createUniqueId() {\n  return Date.now() + '_' + Math.floor(Math.random() * 10000)\n}\n\n/*\n  Validate any returned value from a function. Has\n  to be nothing or an object\n*/\nfunction isValidResult(result) {\n  return !result || (typeof result === 'object' && !Array.isArray(result))\n}\n\n/*\n  Create an error with execution details\n*/\nfunction createErrorObject(error, execution, functionDetails, payload) {\n  const errorToReturn = error\n\n  errorToReturn.execution = execution\n  errorToReturn.functionDetails = functionDetails\n  errorToReturn.payload = Object.assign({}, payload, {\n    _execution: {\n      id: execution.id,\n      functionIndex: functionDetails.functionIndex,\n    },\n    error: error.toJSON\n      ? error.toJSON()\n      : {\n          name: error.name,\n          message: error.message,\n          stack: error.stack,\n        },\n  })\n\n  return errorToReturn\n}\n\n/*\n  If it walks like a duck and quacks like a duck...\n*/\nfunction isPromise(result) {\n  return (\n    result &&\n    typeof result.then === 'function' &&\n    typeof result.catch === 'function'\n  )\n}\n\nclass FunctionTreeExecution {\n  constructor(name, staticTree, functionTree, errorCallback) {\n    this.id = createUniqueId()\n    this.name = name || staticTree.name || this.id\n    this.staticTree = staticTree\n    this.functionTree = functionTree\n    this.datetime = Date.now()\n    this.errorCallback = errorCallback\n    this.hasThrown = false\n\n    this.runFunction = this.runFunction.bind(this)\n  }\n\n  /*\n    Creates the context for the current function to be run,\n    emits events and handles its returned value. Also handles\n    the returned value being a promise\n  */\n  runFunction(funcDetails, payload, prevPayload, next) {\n    if (this.hasThrown) {\n      return\n    }\n\n    const context = this.createContext(funcDetails, payload, prevPayload)\n    const functionTree = this.functionTree\n    const errorCallback = this.errorCallback\n    const execution = this\n    let result\n\n    functionTree.emit('functionStart', execution, funcDetails, payload)\n    try {\n      result = funcDetails.function(context)\n    } catch (error) {\n      this.hasThrown = true\n\n      return errorCallback(\n        createErrorObject(error, execution, funcDetails, payload),\n        execution,\n        funcDetails,\n        payload\n      )\n    }\n\n    /*\n      If result is a promise we want to emit an event and wait for it to resolve to\n      move on\n    */\n    if (isPromise(result)) {\n      functionTree.emit(\n        'asyncFunction',\n        execution,\n        funcDetails,\n        payload,\n        result\n      )\n      result\n        .then(function(result) {\n          if (result instanceof Path) {\n            functionTree.emit(\n              'functionEnd',\n              execution,\n              funcDetails,\n              payload,\n              result\n            )\n            next(result.toJSON())\n          } else if (funcDetails.outputs) {\n            functionTree.emit(\n              'functionEnd',\n              execution,\n              funcDetails,\n              payload,\n              result\n            )\n            throw new FunctionTreeExecutionError(\n              execution,\n              funcDetails,\n              payload,\n              new Error(\n                'The result ' +\n                  JSON.stringify(result) +\n                  ' from function ' +\n                  funcDetails.name +\n                  ' needs to be a path of either ' +\n                  Object.keys(funcDetails.outputs)\n              )\n            )\n          } else if (isValidResult(result)) {\n            functionTree.emit(\n              'functionEnd',\n              execution,\n              funcDetails,\n              payload,\n              result\n            )\n            next({\n              payload: result,\n            })\n          } else {\n            functionTree.emit(\n              'functionEnd',\n              execution,\n              funcDetails,\n              payload,\n              result\n            )\n            throw new FunctionTreeExecutionError(\n              execution,\n              funcDetails,\n              payload,\n              new Error(\n                'The result ' +\n                  JSON.stringify(result) +\n                  ' from function ' +\n                  funcDetails.name +\n                  ' is not a valid result'\n              )\n            )\n          }\n        })\n        .catch(function(result) {\n          if (result instanceof Error) {\n            execution.hasThrown = true\n            errorCallback(\n              createErrorObject(result, execution, funcDetails, payload),\n              execution,\n              funcDetails,\n              payload\n            )\n          } else if (result instanceof Path) {\n            functionTree.emit(\n              'functionEnd',\n              execution,\n              funcDetails,\n              payload,\n              result\n            )\n            next(result.toJSON())\n          } else if (funcDetails.outputs) {\n            let error = new FunctionTreeExecutionError(\n              execution,\n              funcDetails,\n              payload,\n              new Error(\n                'The result ' +\n                  JSON.stringify(result) +\n                  ' from function ' +\n                  funcDetails.name +\n                  ' needs to be a path of either ' +\n                  Object.keys(funcDetails.outputs)\n              )\n            )\n\n            execution.hasThrown = true\n            errorCallback(\n              createErrorObject(error, execution, funcDetails, payload),\n              execution,\n              funcDetails,\n              payload\n            )\n          } else if (isValidResult(result)) {\n            functionTree.emit(\n              'functionEnd',\n              execution,\n              funcDetails,\n              payload,\n              result\n            )\n            next({\n              payload: result,\n            })\n          } else {\n            let error = new FunctionTreeExecutionError(\n              execution,\n              funcDetails,\n              payload,\n              new Error(\n                'The result ' +\n                  JSON.stringify(result) +\n                  ' from function ' +\n                  funcDetails.name +\n                  ' is not a valid result'\n              )\n            )\n            execution.hasThrown = true\n\n            errorCallback(\n              createErrorObject(error, execution, funcDetails, payload),\n              execution,\n              funcDetails,\n              payload\n            )\n          }\n        })\n    } else if (result instanceof Path) {\n      functionTree.emit('functionEnd', execution, funcDetails, payload, result)\n      next(result.toJSON())\n    } else if (funcDetails.outputs) {\n      let error = new FunctionTreeExecutionError(\n        execution,\n        funcDetails,\n        payload,\n        new Error(\n          'The result ' +\n            JSON.stringify(result) +\n            ' from function ' +\n            funcDetails.name +\n            ' needs to be a path of either ' +\n            Object.keys(funcDetails.outputs)\n        )\n      )\n\n      this.hasThrown = true\n      errorCallback(\n        createErrorObject(error, execution, funcDetails, payload),\n        execution,\n        funcDetails,\n        payload\n      )\n    } else if (isValidResult(result)) {\n      functionTree.emit('functionEnd', execution, funcDetails, payload, result)\n      next({\n        payload: result,\n      })\n    } else {\n      let error = new FunctionTreeExecutionError(\n        execution,\n        funcDetails,\n        payload,\n        new Error(\n          'The result ' +\n            JSON.stringify(result) +\n            ' from function ' +\n            funcDetails.name +\n            ' is not a valid result'\n        )\n      )\n      this.hasThrown = true\n\n      errorCallback(\n        createErrorObject(error, execution, funcDetails, payload),\n        execution,\n        funcDetails,\n        payload\n      )\n    }\n  }\n\n  /*\n    Creates the context for the next running function\n  */\n  createContext(funcDetails, payload, prevPayload) {\n    return [ExecutionProvider(this), PropsProvider(), PathProvider()]\n      .concat(this.functionTree.contextProviders)\n      .reduce(function(currentContext, contextProvider) {\n        const newContext = typeof contextProvider === 'function'\n          ? contextProvider(currentContext, funcDetails, payload, prevPayload)\n          : ContextProvider(contextProvider)(\n              currentContext,\n              funcDetails,\n              payload,\n              prevPayload\n            )\n\n        if (newContext !== currentContext) {\n          throw new FunctionTreeError(\n            'A provider is not returning the context object, maybe it is a function factory and you forgot to call it?'\n          )\n        }\n\n        return newContext\n      }, {})\n  }\n}\n\nexport class FunctionTree extends EventEmitter {\n  constructor(contextProviders) {\n    super()\n    this.cachedTrees = []\n    this.cachedStaticTrees = []\n    if (Array.isArray(contextProviders)) {\n      this.contextProviders = contextProviders\n    } else if (contextProviders) {\n      this.contextProviders = [ContextProvider(contextProviders)]\n    } else {\n      this.contextProviders = []\n    }\n\n    this.run = this.run.bind(this)\n  }\n\n  /*\n    Analyses the tree to identify paths and its validity. This analysis\n    is cached. Then the method creates an execution for the tree to run.\n  */\n  run() {\n    let name\n    let tree\n    let payload\n    let cb\n    let staticTree\n    const args = [].slice.call(arguments)\n    args.forEach(arg => {\n      if (typeof arg === 'string') {\n        name = arg\n      } else if (Array.isArray(arg) || arg instanceof Primitive) {\n        tree = arg\n      } else if (!tree && typeof arg === 'function') {\n        tree = arg\n      } else if (typeof arg === 'function') {\n        cb = arg\n      } else {\n        payload = arg\n      }\n    })\n\n    if (!tree) {\n      throw new Error('function-tree - You did not pass in a function tree')\n    }\n\n    const withResolveAndReject = (resolve, reject) => {\n      const treeIdx = this.cachedTrees.indexOf(tree)\n      if (treeIdx === -1) {\n        staticTree = createStaticTree(tree)\n        this.cachedTrees.push(tree)\n        this.cachedStaticTrees.push(staticTree)\n      } else {\n        staticTree = this.cachedStaticTrees[treeIdx]\n      }\n      const execution = new FunctionTreeExecution(\n        name,\n        staticTree,\n        this,\n        (error, execution, funcDetails, finalPayload) => {\n          this.emit('error', error, execution, funcDetails, finalPayload)\n          reject(error)\n        }\n      )\n\n      this.emit('start', execution, payload)\n      executeTree(\n        execution,\n        payload,\n        (funcDetails, path, currentPayload) => {\n          this.emit('pathStart', path, execution, funcDetails, currentPayload)\n        },\n        currentPayload => {\n          this.emit('pathEnd', execution, currentPayload)\n        },\n        (currentPayload, functionsToResolve) => {\n          this.emit(\n            'parallelStart',\n            execution,\n            currentPayload,\n            functionsToResolve\n          )\n        },\n        (currentPayload, functionsResolved) => {\n          this.emit(\n            'parallelProgress',\n            execution,\n            currentPayload,\n            functionsResolved\n          )\n        },\n        (currentPayload, functionsResolved) => {\n          this.emit('parallelEnd', execution, currentPayload, functionsResolved)\n        },\n        finalPayload => {\n          this.emit('end', execution, finalPayload)\n          resolve === reject\n            ? resolve(null, finalPayload)\n            : resolve(finalPayload)\n        }\n      )\n    }\n\n    if (cb) {\n      withResolveAndReject(cb, cb)\n    } else {\n      return new Promise(withResolveAndReject)\n    }\n  }\n}\n"]}