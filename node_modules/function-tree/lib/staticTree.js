'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _primitives = require('./primitives');

var _errors = require('./errors');

function getFunctionName(fn) {
  var ret = fn.toString();
  ret = ret.substr('function '.length);
  ret = ret.substr(0, ret.indexOf('('));

  return ret;
}

function isPaths(item) {
  return item && !Array.isArray(item) && (typeof item === 'undefined' ? 'undefined' : _typeof(item)) === 'object' && !(item instanceof _primitives.Primitive);
}

function analyze(functions, item, isParallel) {
  if (item instanceof _primitives.Primitive) {
    var instance = item.toJSON();

    return Object.assign(instance, {
      items: analyze(functions, instance.items, item instanceof _primitives.Parallel).items
    });
  } else if (Array.isArray(item)) {
    return new _primitives.Sequence(item.reduce(function (allItems, subItem, index) {
      if (subItem instanceof _primitives.Primitive) {
        var _instance = subItem.toJSON();

        return allItems.concat(Object.assign(_instance, {
          items: analyze(functions, _instance.items, subItem instanceof _primitives.Parallel).items
        }));
      } else if (typeof subItem === 'function') {
        var funcDetails = {
          name: subItem.displayName || getFunctionName(subItem),
          functionIndex: functions.push(subItem) - 1,
          function: subItem
        };
        var nextItem = item[index + 1];

        if (isPaths(nextItem)) {
          funcDetails.outputs = {};
          Object.keys(nextItem).forEach(function (key) {
            if (subItem.outputs && !~subItem.outputs.indexOf(key)) {
              throw new _errors.FunctionTreeError('Outputs object doesn\'t match list of possible outputs defined for function.');
            }
            funcDetails.outputs[key] = analyze(functions, typeof nextItem[key] === 'function' ? [nextItem[key]] : nextItem[key]);
          });
        }

        return allItems.concat(funcDetails);
      } else if (isPaths(subItem)) {
        return allItems;
      } else if (Array.isArray(subItem)) {
        var items = analyze(functions, subItem);

        return allItems.concat(items);
      } else {
        throw new _errors.FunctionTreeError('Unexpected entry in tree');
      }
    }, [])).toJSON();
  } else {
    throw new _errors.FunctionTreeError('Unexpected entry in tree');
  }
}

exports.default = function (tree) {
  var functions = [];

  return analyze(functions, typeof tree === 'function' ? [tree] : tree);
};
//# sourceMappingURL=staticTree.js.map