'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ = require('../../');

var _View = require('../View');

var _View2 = _interopRequireDefault(_View);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CerebralScope = function () {
  function CerebralScope(ctrl, scope, dependencies, controller) {
    var _this = this;

    _classCallCheck(this, CerebralScope);

    this.ctrl = ctrl;
    this.scope = scope;
    this.onUpdate = this.onUpdate.bind(this);
    this.ctrl.$onInit = function () {
      _this.props = Object.assign({}, _this.ctrl);

      _this.view = new _View2.default({
        dependencies: dependencies,
        mergeProps: null,
        props: _this.props,
        controller: controller,
        displayName: 'Unknown',
        onUpdate: _this.onUpdate
      });
      _this.view.onMount();
      _this.ctrl.$onDestroy = function () {
        _this.view.onUnMount();
        delete _this.ctrl;
        delete _this.scope;
      };
      _this.ctrl.$onChanges = function (changesObj) {
        var _Object$keys$reduce = Object.keys(changesObj).reduce(function (updates, key) {
          updates.oldProps[key] = changesObj[key].previousValue;
          updates.nextProps[key] = changesObj[key].currentValue;

          return updates;
        }, { oldProps: {}, nextProps: {} }),
            oldProps = _Object$keys$reduce.oldProps,
            nextProps = _Object$keys$reduce.nextProps;

        var hasUpdate = _this.view.onPropsUpdate(oldProps, nextProps);

        if (hasUpdate) {
          Object.assign(_this.ctrl, _this.view.getProps(nextProps));
          _this.scope.safeApply();
        }
      };
      _this.scope.safeApply = function (fn) {
        var phase = this.$root.$$phase;
        if (phase === '$apply' || phase === '$digest') {
          if (fn && typeof fn === 'function') {
            fn();
          }
        } else {
          this.$apply(fn);
        }
      };
      Object.assign(_this.ctrl, _this.view.getProps(_this.props));
    };
  }

  _createClass(CerebralScope, [{
    key: 'onUpdate',
    value: function onUpdate(stateChanges, force) {
      this.view.updateFromState(stateChanges, this.props, force);
      Object.assign(this.ctrl, this.view.getProps(this.props));
      this.scope.safeApply();
    }
  }]);

  return CerebralScope;
}();

exports.default = function (angular) {
  angular.module('cerebral', []).provider('cerebral', function () {
    var config = null;

    this.configure = function (controllerConfig) {
      config = controllerConfig;
    };

    this.$get = ['$injector', function ($injector) {
      config.providers = (config.providers || []).concat((config.services || []).map(function (service) {
        return (0, _.provide)(service, $injector.get(service));
      }));
      var controller = new _.Controller(config);

      return {
        connect: function connect(ctrl, scope, depdendencies) {
          return new CerebralScope(ctrl, scope, depdendencies, controller);
        }
      };
    }];
  });
};
//# sourceMappingURL=module.js.map