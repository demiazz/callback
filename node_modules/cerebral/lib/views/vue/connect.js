'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = connect;

var _View = require('../View');

var _View2 = _interopRequireDefault(_View);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function connect(dependencies, component) {
  component.inject = component.inject ? component.inject.concat(['cerebral_controller']) : ['cerebral_controller'];

  component.methods = Object.assign(component.methods || {}, {
    _cererebral_onUpdate: function _cererebral_onUpdate(stateChanges, force) {
      this.view.updateFromState(stateChanges, this.$props, force);
      Object.assign(this, this.view.getProps(this.$props));
      this.$forceUpdate();
    }
  });

  var existingBeforeMount = component.beforeMount;
  component.beforeMount = function () {
    var _this = this;

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    existingBeforeMount && existingBeforeMount.call.apply(existingBeforeMount, [this].concat(args));

    this.view = new _View2.default({
      dependencies: dependencies,
      mergeProps: null,
      props: this.$props,
      controller: this.cerebral_controller,
      displayName: component.name || 'NoName',
      onUpdate: this._cererebral_onUpdate
    });

    this.view.onMount();
    Object.assign(this, this.view.getProps(this.$props));

    Object.keys(this.$props).forEach(function (prop) {
      _this.$watch(prop, function (newVal, oldVal) {
        var oldProps = Object.assign({}, this.$props, _defineProperty({}, prop, oldVal));
        var hasUpdate = this.view.onPropsUpdate(oldProps, this.$props);

        if (hasUpdate) {
          Object.assign(this, this.view.getProps(this.$props));
          this.$forceUpdate();
        }
      });
    });
  };

  var existingBeforeDestroyed = component.beforeDestroyed;
  component.beforeDestroyed = function () {
    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    existingBeforeDestroyed && existingBeforeDestroyed.call.apply(existingBeforeDestroyed, [this].concat(args));
    this.view.onUnMount();
  };
  return component;
}
//# sourceMappingURL=connect.js.map