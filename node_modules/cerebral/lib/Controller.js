'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _DependencyStore = require('./DependencyStore');

var _DependencyStore2 = _interopRequireDefault(_DependencyStore);

var _functionTree = require('function-tree');

var _functionTree2 = _interopRequireDefault(_functionTree);

var _Module = require('./Module');

var _Module2 = _interopRequireDefault(_Module);

var _Model = require('./Model');

var _Model2 = _interopRequireDefault(_Model);

var _utils = require('./utils');

var _VerifyProps = require('./providers/VerifyProps');

var _VerifyProps2 = _interopRequireDefault(_VerifyProps);

var _State = require('./providers/State');

var _State2 = _interopRequireDefault(_State);

var _Debugger = require('./providers/Debugger');

var _Debugger2 = _interopRequireDefault(_Debugger);

var _Controller = require('./providers/Controller');

var _Controller2 = _interopRequireDefault(_Controller);

var _Resolve = require('./providers/Resolve');

var _Resolve2 = _interopRequireDefault(_Resolve);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function getModule(path, modules) {
  var pathArray = Array.isArray(path) ? path : path.split('.');
  return pathArray.reduce(function (currentModule, key) {
    if (!currentModule.modules[key]) {
      (0, _utils.throwError)('The path "' + pathArray.join('.') + '" is invalid, can not find module. Does the path "' + pathArray.splice(0, path.length - 1).join('.') + '" exist?');
    }
    return currentModule.modules[key];
  }, modules);
}
/*
  The controller is where everything is attached. The devtools
  and router is attached directly. Also a top level module is created.
  The controller creates the function tree that will run all signals,
  based on top level providers and providers defined in modules
*/

var Controller = function (_FunctionTree) {
  _inherits(Controller, _FunctionTree);

  function Controller(config) {
    _classCallCheck(this, Controller);

    var _this = _possibleConstructorReturn(this, (Controller.__proto__ || Object.getPrototypeOf(Controller)).call(this));

    var _config$state = config.state,
        state = _config$state === undefined ? {} : _config$state,
        _config$signals = config.signals,
        signals = _config$signals === undefined ? {} : _config$signals,
        _config$providers = config.providers,
        providers = _config$providers === undefined ? [] : _config$providers,
        _config$modules = config.modules,
        modules = _config$modules === undefined ? {} : _config$modules,
        router = config.router,
        _config$devtools = config.devtools,
        devtools = _config$devtools === undefined ? null : _config$devtools,
        _config$options = config.options,
        options = _config$options === undefined ? {} : _config$options;

    var getSignal = _this.getSignal;

    _this.getSignal = function () {
      (0, _utils.throwError)('You are grabbing a signal before controller has initialized, please wait for "initialized" event');
    };

    if (router) {
      console.warn('DEPRECATION: the \'router\' module should be in modules.');
      modules.router = router;
    }

    _this.componentDependencyStore = new _DependencyStore2.default();
    _this.options = options;
    _this.catch = config.catch || null;
    _this.flush = _this.flush.bind(_this);
    _this.devtools = devtools;
    _this.model = new _Model2.default({}, _this.devtools);
    _this.module = new _Module2.default(_this, [], {
      state: state,
      signals: signals,
      modules: modules
    });

    if (options.strictRender) {
      console.warn('DEPRECATION - No need to use strictRender option anymore, it is the only render mode now');
    }

    _this.contextProviders = [(0, _Controller2.default)(_this)].concat(_this.devtools ? [(0, _Debugger2.default)()] : []).concat((0, _utils.isDeveloping)() ? [_VerifyProps2.default] : []).concat((0, _State2.default)(), (0, _Resolve2.default)()).concat(providers.concat((0, _utils.getProviders)(_this.module)));

    _this.on('asyncFunction', function (execution, funcDetails) {
      if (!funcDetails.isParallel) {
        _this.flush();
      }
    });
    _this.on('parallelStart', function () {
      return _this.flush();
    });
    _this.on('parallelProgress', function (execution, currentPayload, functionsResolving) {
      if (functionsResolving === 1) {
        _this.flush();
      }
    });
    _this.on('end', function () {
      return _this.flush();
    });

    if (typeof window !== 'undefined' && window.CEREBRAL_STATE) {
      Object.keys(window.CEREBRAL_STATE).forEach(function (statePath) {
        _this.model.set(statePath.split('.'), window.CEREBRAL_STATE[statePath]);
      });
    }

    if (_this.devtools) {
      _this.devtools.init(_this);
    }

    if (!_this.devtools && (0, _utils.isDeveloping)() && typeof navigator !== 'undefined' && /Chrome/.test(navigator.userAgent)) {
      console.warn('You are not using the Cerebral devtools. It is highly recommended to use it in combination with the debugger: http://cerebraljs.com/docs/get_started/debugger.html');
    }

    _this.getSignal = getSignal;

    _this.model.flush();

    _this.emit('initialized');
    return _this;
  }
  /*
    Whenever components needs to be updated, this method
    can be called
  */


  _createClass(Controller, [{
    key: 'flush',
    value: function flush(force) {
      var changes = this.model.flush();

      if (!force && !Object.keys(changes).length) {
        return;
      }

      this.updateComponents(changes, force);
      this.emit('flush', changes, Boolean(force));
    }
  }, {
    key: 'updateComponents',
    value: function updateComponents(changes, force) {
      var _this2 = this;

      var componentsToRender = [];

      if (force) {
        componentsToRender = this.componentDependencyStore.getAllUniqueEntities();
      } else {
        componentsToRender = this.componentDependencyStore.getUniqueEntities(changes);
      }

      var start = Date.now();
      componentsToRender.forEach(function (component) {
        if (_this2.devtools) {
          _this2.devtools.updateComponentsMap(component);
        }
        component.onUpdate(changes, force);
      });
      var end = Date.now();

      if (this.devtools && componentsToRender.length) {
        this.devtools.sendComponentsMap(componentsToRender, changes, start, end);
      }
    }
    /*
      Conveniance method for grabbing the model
    */

  }, {
    key: 'getModel',
    value: function getModel() {
      return this.model;
    }
    /*
      Method called by view to grab state
    */

  }, {
    key: 'getState',
    value: function getState(path) {
      return this.model.get((0, _utils.ensurePath)((0, _utils.cleanPath)(path)));
    }
    /*
      Uses function tree to run the array and optional
      payload passed in. The payload will be checkd
    */

  }, {
    key: 'runSignal',
    value: function runSignal(name, signal) {
      var _this3 = this;

      var payload = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (this.devtools && (!(0, _utils.isObject)(payload) || !(0, _utils.isSerializable)(payload))) {
        console.warn('You passed an invalid payload to signal "' + name + '". Only serializable payloads can be passed to a signal. The payload has been ignored. This is the object:', payload);
        payload = {};
      }

      if (this.devtools) {
        payload = Object.keys(payload).reduce(function (currentPayload, key) {
          if (!(0, _utils.isSerializable)(payload[key], _this3.devtools.allowedTypes)) {
            console.warn('You passed an invalid payload to signal "' + name + '", on key "' + key + '". Only serializable values like Object, Array, String, Number and Boolean can be passed in. Also these special value types:', _this3.devtools.allowedTypes);

            return currentPayload;
          }

          currentPayload[key] = (0, _utils.forceSerializable)(payload[key]);

          return currentPayload;
        }, {});
      }

      this.run(name, signal, payload, function (error) {
        if (error) {
          var signalPath = error.execution.name.split('.');
          var signalCatch = signalPath.reduce(function (currentModule, key, index) {
            if (index === signalPath.length - 1 && currentModule.signals[key]) {
              return currentModule.signals[key].catch;
            }

            return currentModule ? currentModule.modules[key] : null;
          }, _this3.module);

          // if signal doesn't have a catch method and we have a global catch, try using it
          if (!signalCatch) {
            if (_this3.catch instanceof Map) {
              signalCatch = _this3.catch;
            } else {
              throw error;
            }
          }

          if (signalCatch instanceof Map) {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = signalCatch[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var _step$value = _slicedToArray(_step.value, 2),
                    errorType = _step$value[0],
                    signalChain = _step$value[1];

                if (error instanceof errorType) {
                  _this3.runSignal('catch', signalChain, error.payload);

                  return;
                }
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                  _iterator.return();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
          }

          throw error;
        }
      });
    }
    /*
      Returns a function which binds the name/path of signal,
      and the array. This allows view layer to just call it with
      an optional payload and it will run
    */

  }, {
    key: 'getSignal',
    value: function getSignal(path) {
      var pathArray = (0, _utils.ensurePath)(path);
      var signalKey = pathArray.pop();
      var module = pathArray.reduce(function (currentModule, key) {
        return currentModule ? currentModule.modules[key] : undefined;
      }, this.module);
      var signal = module && module.signals[signalKey];

      if (!signal) {
        (0, _utils.throwError)('There is no signal at path "' + path + '"');
      }

      return signal.run;
    }
  }, {
    key: 'addModule',
    value: function addModule(path, module) {
      var pathArray = path.split('.');
      var moduleKey = pathArray.pop();
      var parentModule = getModule(pathArray, this.module);
      parentModule.modules[moduleKey] = new _Module2.default(this, path.split('.'), module);

      if (module.provider) {
        this.contextProviders.push(module.provider);
      }

      this.flush();
    }
  }, {
    key: 'removeModule',
    value: function removeModule(path) {
      if (!path) {
        console.warn('Controller.removeModule requires a Module Path');
        return null;
      }

      var pathArray = path.split('.');
      var moduleKey = pathArray.pop();
      var parentModule = getModule(pathArray, this.module);

      var module = parentModule.modules[moduleKey];

      if (module.provider) {
        this.contextProviders.splice(this.contextProviders.indexOf(module.provider), 1);
      }

      delete parentModule.modules[moduleKey];

      this.model.unset(path.split('.'));

      this.flush();
    }
  }]);

  return Controller;
}(_functionTree2.default);

exports.default = Controller;
//# sourceMappingURL=Controller.js.map