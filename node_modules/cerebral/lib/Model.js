'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _utils = require('./utils');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Model = function () {
  function Model() {
    var initialState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var devtools = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    _classCallCheck(this, Model);

    this.devtools = devtools;
    this.preventExternalMutations = devtools ? devtools.preventExternalMutations : false;

    this.state = this.preventExternalMutations ? this.freezeObject(initialState) : initialState;
    this.changedPaths = [];
  }
  /*
    Does an unfreeze and update of value, before freezing again
  */


  _createClass(Model, [{
    key: 'unfreezeObject',
    value: function unfreezeObject(value) {
      if (Array.isArray(value)) {
        return value.slice();
      } else if ((0, _utils.isObject)(value)) {
        return Object.assign({}, value);
      }

      return value;
    }
    /*
      Freezes objects and arrays recursively to avoid unwanted mutation
    */

  }, {
    key: 'freezeObject',
    value: function freezeObject(object) {
      if (!Object.isFrozen(object) && (0, _utils.isComplexObject)(object)) {
        for (var key in object) {
          // Properties might not be writable, but then there
          // is not reason to freeze its value either
          try {
            object[key] = this.freezeObject(object[key]);
          } catch (e) {}
        }

        Object.freeze(object);
      }

      return object;
    }
    /*
      Returns array of changes
    */

  }, {
    key: 'flush',
    value: function flush() {
      var changes = this.changedPaths.slice();

      this.changedPaths = [];

      return changes;
    }
    /*
      A generic method for making a change to a path, used
      by multiple mutation methods. Only adds to flush when value
      actually changed. Complex objects always causes a flush due to
      for example array sorting
    */

  }, {
    key: 'updateIn',
    value: function updateIn(path, cb) {
      var _this = this;

      var forceChildPathUpdates = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      if (!path.length) {
        cb(this.state, this, 'state');
        this.state = this.preventExternalMutations ? this.freezeObject(this.state) : this.state;

        return;
      }

      if (this.preventExternalMutations) {
        this.updateInFrozen(path, cb, forceChildPathUpdates);

        return;
      }

      path.reduce(function (currentState, key, index) {
        if (index === path.length - 1) {
          if (!Array.isArray(currentState) && !(0, _utils.isObject)(currentState)) {
            (0, _utils.throwError)('The path "' + path.join('.') + '" is invalid, can not update state. Does the path "' + path.join('.') + '" exist?');
          }

          var currentValue = currentState[key];

          cb(currentState[key], currentState, key);
          if (currentState[key] !== currentValue || (0, _utils.isComplexObject)(currentState[key]) && (0, _utils.isComplexObject)(currentValue)) {
            _this.changedPaths.push({
              path: path,
              forceChildPathUpdates: forceChildPathUpdates
            });
          }
        } else if (!currentState[key]) {
          (0, _utils.throwError)('The path "' + path.join('.') + '" is invalid, can not update state. Does the path "' + path.splice(0, path.length - 1).join('.') + '" exist?');
        }

        return currentState[key];
      }, this.state);
    }
    /*
      Unfreezes on the way down. When done freezes state. It is optimized
      to not go down already frozen paths
    */

  }, {
    key: 'updateInFrozen',
    value: function updateInFrozen(path, cb, forceChildPathUpdates) {
      var _this2 = this;

      this.state = this.unfreezeObject(this.state);
      path.reduce(function (currentState, key, index) {
        if (index === path.length - 1) {
          if (!Array.isArray(currentState) && !(0, _utils.isObject)(currentState)) {
            (0, _utils.throwError)('The path "' + path.join('.') + '" is invalid, can not update state. Does the path "' + path.join('.') + '" exist?');
          }
          currentState[key] = _this2.unfreezeObject(currentState[key]);

          var currentValue = currentState[key];
          cb(currentState[key], currentState, key);

          if (currentState[key] !== currentValue || (0, _utils.isComplexObject)(currentState[key]) && (0, _utils.isComplexObject)(currentValue)) {
            _this2.changedPaths.push({
              path: path,
              forceChildPathUpdates: forceChildPathUpdates
            });
          }
        } else if (!currentState[key]) {
          (0, _utils.throwError)('The path "' + path.join('.') + '" is invalid, can not update state. Does the path "' + path.splice(0, path.length - 1).join('.') + '" exist?');
        } else {
          currentState[key] = _this2.unfreezeObject(currentState[key]);
        }

        return currentState[key];
      }, this.state);

      this.freezeObject(this.state);
    }
    /*
      Checks if value is serializable, if turned on
    */

  }, {
    key: 'verifyValue',
    value: function verifyValue(value, path) {
      if (this.devtools && !(0, _utils.isSerializable)(value, this.devtools.allowedTypes)) {
        (0, _utils.throwError)('You are passing a non serializable value into the state tree on path "' + path.join('.') + '"');
      }
      if (this.devtools) {
        (0, _utils.forceSerializable)(value);
      }
    }
  }, {
    key: 'verifyValues',
    value: function verifyValues(values, path) {
      var _this3 = this;

      if (this.devtools) {
        values.forEach(function (value) {
          _this3.verifyValue(value, path);
        });
      }
    }
  }, {
    key: 'get',
    value: function get() {
      var path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      return path.reduce(function (currentState, key) {
        return currentState ? currentState[key] : undefined;
      }, this.state);
    }
  }, {
    key: 'set',
    value: function set(path, value) {
      this.verifyValue(value, path);
      this.updateIn(path, function (_, parent, key) {
        parent[key] = value;
      }, true);
    }
  }, {
    key: 'toggle',
    value: function toggle(path) {
      this.updateIn(path, function (value, parent, key) {
        parent[key] = !value;
      });
    }
  }, {
    key: 'push',
    value: function push(path, value) {
      this.verifyValue(value, path);
      this.updateIn(path, function (array) {
        array.push(value);
      });
    }
  }, {
    key: 'merge',
    value: function merge(path) {
      for (var _len = arguments.length, values = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        values[_key - 1] = arguments[_key];
      }

      var value = Object.assign.apply(Object, values);

      // If we already have an object we make it behave
      // like multiple sets, indicating a change to very key.
      // If no value it should indicate that we are setting
      // a new object
      if (this.get(path)) {
        for (var prop in value) {
          this.set(path.concat(prop), value[prop]);
        }
      } else {
        this.set(path, value);
      }
    }
  }, {
    key: 'pop',
    value: function pop(path) {
      this.updateIn(path, function (array) {
        array.pop();
      });
    }
  }, {
    key: 'shift',
    value: function shift(path) {
      this.updateIn(path, function (array) {
        array.shift();
      });
    }
  }, {
    key: 'unshift',
    value: function unshift(path, value) {
      this.verifyValue(value, path);
      this.updateIn(path, function (array) {
        array.unshift(value);
      });
    }
  }, {
    key: 'splice',
    value: function splice(path) {
      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      this.verifyValues(args, path);
      this.updateIn(path, function (array) {
        array.splice.apply(array, args);
      });
    }
  }, {
    key: 'unset',
    value: function unset(path) {
      this.updateIn(path, function (_, parent, key) {
        delete parent[key];
      }, true);
    }
  }, {
    key: 'concat',
    value: function concat(path, value) {
      this.verifyValue(value, path);
      this.updateIn(path, function (array, parent, key) {
        parent[key] = array.concat(value);
      });
    }
  }]);

  return Model;
}();

exports.default = Model;
//# sourceMappingURL=Model.js.map