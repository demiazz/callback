'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = require('../utils');

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function StateProviderFactory() {
  var methods = ['get', 'set', 'toggle', 'push', 'merge', 'pop', 'shift', 'unshift', 'splice', 'unset', 'concat'];
  var provider = null;

  function createProvider(context) {
    var model = context.controller.model;
    var asyncTimeout = null;

    return methods.reduce(function (currentStateContext, methodKey) {
      currentStateContext[methodKey] = function () {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        var path = (0, _utils.ensurePath)((0, _utils.cleanPath)(args.shift()));

        if (methodKey !== 'get') {
          clearTimeout(asyncTimeout);
          asyncTimeout = setTimeout(function () {
            return context.controller.flush();
          });
        }

        return model[methodKey].apply(model, [path].concat(args));
      };

      return currentStateContext;
    }, {});
  }

  function StateProvider(context, functionDetails) {
    context.state = provider = provider || createProvider(context);

    if (context.debugger) {
      context.state = methods.reduce(function (currentState, methodKey) {
        if (methodKey === 'get' || methodKey === 'compute') {
          currentState[methodKey] = provider[methodKey];
        } else {
          var originFunc = provider[methodKey];

          currentState[methodKey] = function () {
            for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
            }

            var argsCopy = args.slice();
            var path = (0, _utils.ensurePath)(argsCopy.shift());

            context.debugger.send({
              datetime: Date.now(),
              type: 'mutation',
              color: '#333',
              method: methodKey,
              args: [path].concat(_toConsumableArray(argsCopy))
            });

            try {
              originFunc.apply(context.controller.model, args);
            } catch (e) {
              var signalName = context.execution.name;
              (0, _utils.throwError)('The Signal "' + signalName + '" with action "' + functionDetails.name + '" has an error: ' + e.message);
            }
          };
        }

        return currentState;
      }, {});
    }

    return context;
  }

  return StateProvider;
}

exports.default = StateProviderFactory;
//# sourceMappingURL=State.js.map