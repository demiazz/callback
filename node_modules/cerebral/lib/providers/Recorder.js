'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = RecorderProvider;
function RecorderProvider() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var timeout = options.setTimeout || setTimeout;

  var mutationMethods = ['set', 'push', 'merge', 'pop', 'shift', 'unshift', 'splice', 'unset', 'concat'];
  var provider = null;

  /*
    We create the provider on the first signal execution
  */
  function createProvider(context) {
    var controller = context.controller;
    // We will override the origin runSignal method to block
    // signals from running while playing back recording
    var originalRunSignal = controller.runSignal;
    var allowedSignals = [];
    var currentRecording = null;
    var currentSeek = 0;
    var currentEventIndex = 0;
    var lastEventTimestamp = 0;
    var nextEventTimeout = null;
    var started = null;
    var ended = null;
    var isPlaying = false;
    var _isRecording = false;

    // We need to record flush events to update the UI
    // at the same time as during the recording
    controller.on('flush', function () {
      if (_isRecording) {
        currentRecording.events.push({
          type: 'flush',
          timestamp: Date.now()
        });
      }
    });

    function addExternalEvent(type, data) {
      currentRecording.events.push({
        type: type,
        timestamp: Date.now(),
        data: data
      });
    }

    function updateDebugger(method, path, args) {
      if (context.debugger && typeof window !== 'undefined' && window.CustomEvent) {
        var event = new window.CustomEvent('cerebral2.client.message', {
          detail: JSON.stringify({
            type: 'recorderMutation',
            data: {
              method: method,
              path: path,
              args: args
            }
          })
        });
        window.dispatchEvent(event);
      }
    }

    function mutate(mutation) {
      var args = JSON.parse(mutation.args);
      var path = args.shift().split('.');

      controller.model[mutation.method].apply(controller.model, [path].concat(args));
      updateDebugger(mutation.method, path, args);
    }

    // During playback we run events as they were recorded, one after
    // the other
    function runNextEvent() {
      var event = currentRecording.events[currentEventIndex];

      nextEventTimeout = timeout(function () {
        if (event.type === 'mutation') {
          mutate(event);
        } else if (event.type === 'flush') {
          controller.flush();
        } else {
          controller.emit(event.type, event.data);
        }

        lastEventTimestamp = event.timestamp;
        currentEventIndex++;

        if (!currentRecording.events[currentEventIndex]) {
          controller.runSignal = originalRunSignal;
          isPlaying = false;
          currentEventIndex = 0;

          return;
        }

        runNextEvent();
      }, event.timestamp - lastEventTimestamp);
    }

    function resetState() {
      currentRecording.initialState.forEach(function (state) {
        var value = JSON.parse(state.value);

        controller.model.set(state.path, value);
        updateDebugger('set', state.path, [value]);
      });
      for (var x = 0; x < currentEventIndex; x++) {
        if (currentRecording.events[x].type === 'mutation') {
          mutate(currentRecording.events[x]);
        }
      }
    }

    return {
      seek: function seek(_seek) {
        clearTimeout(nextEventTimeout);

        for (var x = 0; x < currentRecording.events.length; x++) {
          currentEventIndex = x;

          var event = currentRecording.events[x];
          if (event.timestamp - currentRecording.start > _seek) {
            break;
          }
        }

        resetState();
        controller.emit('recorder:seek', _seek);
      },
      play: function play() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        if (isPlaying || _isRecording) {
          throw new Error('CEREBRAL Recorder - You can not play while already playing or recording');
        }

        allowedSignals = options.allowedSignals || [];
        resetState();
        isPlaying = true;
        started = Date.now();
        lastEventTimestamp = currentRecording.start;

        controller.runSignal = function () {
          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          if (allowedSignals.indexOf(args[0]) >= 0) {
            originalRunSignal.apply(controller, args);
          }
        };
        controller.flush(true);
        runNextEvent();
        controller.emit('recorder:play', currentSeek, options);
      },
      record: function record() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        // If we are recording over the previous stuff, go back to start
        if (currentRecording) {
          currentSeek = 0;
          ended = null;
        }

        var paths = options.initialState || [''];
        var state = paths.map(function (path) {
          var arrayPath = path ? path.split('.') : [];

          return {
            path: arrayPath,
            value: JSON.stringify(controller.getState(arrayPath))
          };
        });

        currentRecording = {
          initialState: state,
          start: Date.now(),
          events: []
        };

        controller.on('recorder:event', addExternalEvent);

        _isRecording = true;
        controller.emit('recorder:record', options);
      },
      stop: function stop() {
        var wasPlaying = isPlaying;
        clearTimeout(nextEventTimeout);
        isPlaying = false;
        _isRecording = false;
        controller.runSignal = originalRunSignal;
        controller.off('recorder:event', addExternalEvent);

        if (wasPlaying) {
          return;
        }

        currentRecording.end = Date.now();
        currentEventIndex = 0;
        currentRecording.events.push({
          type: 'flush',
          timestamp: Date.now()
        });
        controller.emit('recorder:stop');
      },
      pause: function pause() {
        ended = Date.now();
        currentSeek = ended - started;
        clearTimeout(nextEventTimeout);
        isPlaying = false;
        controller.emit('recorder:pause', currentSeek);
      },
      getRecording: function getRecording() {
        return currentRecording;
      },
      getCurrentSeek: function getCurrentSeek() {
        return currentSeek;
      },
      loadRecording: function loadRecording(recording) {
        currentRecording = recording;
      },
      isRecording: function isRecording() {
        return _isRecording;
      }
    };
  }

  return function Recorder(context) {
    context.recorder = provider = provider || createProvider(context);

    if (context.recorder.isRecording()) {
      context.state = mutationMethods.reduce(function (state, method) {
        var originMethod = state[method];

        state[method] = function () {
          for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          context.recorder.getRecording().events.push({
            type: 'mutation',
            method: method,
            args: JSON.stringify(args),
            timestamp: Date.now()
          });
          originMethod.apply(null, args);
        };

        return state;
      }, context.state);
    }

    return context;
  };
}
//# sourceMappingURL=Recorder.js.map