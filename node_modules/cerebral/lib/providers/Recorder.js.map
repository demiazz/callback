{"version":3,"sources":["../../src/providers/Recorder.js"],"names":["RecorderProvider","options","timeout","setTimeout","mutationMethods","provider","createProvider","context","controller","originalRunSignal","runSignal","allowedSignals","currentRecording","currentSeek","currentEventIndex","lastEventTimestamp","nextEventTimeout","started","ended","isPlaying","isRecording","on","events","push","type","timestamp","Date","now","addExternalEvent","data","updateDebugger","method","path","args","debugger","window","CustomEvent","event","detail","JSON","stringify","dispatchEvent","mutate","mutation","parse","shift","split","model","apply","concat","runNextEvent","flush","emit","resetState","initialState","forEach","value","state","set","x","seek","clearTimeout","length","start","play","Error","indexOf","record","paths","map","arrayPath","getState","stop","wasPlaying","off","end","pause","getRecording","getCurrentSeek","loadRecording","recording","Recorder","recorder","reduce","originMethod"],"mappings":"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","file":"Recorder.js","sourcesContent":["export default function RecorderProvider(options = {}) {\n  const timeout = options.setTimeout || setTimeout\n\n  const mutationMethods = [\n    'set',\n    'push',\n    'merge',\n    'pop',\n    'shift',\n    'unshift',\n    'splice',\n    'unset',\n    'concat',\n  ]\n  let provider = null\n\n  /*\n    We create the provider on the first signal execution\n  */\n  function createProvider(context) {\n    const controller = context.controller\n    // We will override the origin runSignal method to block\n    // signals from running while playing back recording\n    const originalRunSignal = controller.runSignal\n    let allowedSignals = []\n    let currentRecording = null\n    let currentSeek = 0\n    let currentEventIndex = 0\n    let lastEventTimestamp = 0\n    let nextEventTimeout = null\n    let started = null\n    let ended = null\n    let isPlaying = false\n    let isRecording = false\n\n    // We need to record flush events to update the UI\n    // at the same time as during the recording\n    controller.on('flush', () => {\n      if (isRecording) {\n        currentRecording.events.push({\n          type: 'flush',\n          timestamp: Date.now(),\n        })\n      }\n    })\n\n    function addExternalEvent(type, data) {\n      currentRecording.events.push({\n        type,\n        timestamp: Date.now(),\n        data,\n      })\n    }\n\n    function updateDebugger(method, path, args) {\n      if (\n        context.debugger &&\n        typeof window !== 'undefined' &&\n        window.CustomEvent\n      ) {\n        const event = new window.CustomEvent('cerebral2.client.message', {\n          detail: JSON.stringify({\n            type: 'recorderMutation',\n            data: {\n              method,\n              path,\n              args,\n            },\n          }),\n        })\n        window.dispatchEvent(event)\n      }\n    }\n\n    function mutate(mutation) {\n      const args = JSON.parse(mutation.args)\n      const path = args.shift().split('.')\n\n      controller.model[mutation.method].apply(\n        controller.model,\n        [path].concat(args)\n      )\n      updateDebugger(mutation.method, path, args)\n    }\n\n    // During playback we run events as they were recorded, one after\n    // the other\n    function runNextEvent() {\n      const event = currentRecording.events[currentEventIndex]\n\n      nextEventTimeout = timeout(() => {\n        if (event.type === 'mutation') {\n          mutate(event)\n        } else if (event.type === 'flush') {\n          controller.flush()\n        } else {\n          controller.emit(event.type, event.data)\n        }\n\n        lastEventTimestamp = event.timestamp\n        currentEventIndex++\n\n        if (!currentRecording.events[currentEventIndex]) {\n          controller.runSignal = originalRunSignal\n          isPlaying = false\n          currentEventIndex = 0\n\n          return\n        }\n\n        runNextEvent()\n      }, event.timestamp - lastEventTimestamp)\n    }\n\n    function resetState() {\n      currentRecording.initialState.forEach(state => {\n        const value = JSON.parse(state.value)\n\n        controller.model.set(state.path, value)\n        updateDebugger('set', state.path, [value])\n      })\n      for (let x = 0; x < currentEventIndex; x++) {\n        if (currentRecording.events[x].type === 'mutation') {\n          mutate(currentRecording.events[x])\n        }\n      }\n    }\n\n    return {\n      seek(seek) {\n        clearTimeout(nextEventTimeout)\n\n        for (let x = 0; x < currentRecording.events.length; x++) {\n          currentEventIndex = x\n\n          const event = currentRecording.events[x]\n          if (event.timestamp - currentRecording.start > seek) {\n            break\n          }\n        }\n\n        resetState()\n        controller.emit('recorder:seek', seek)\n      },\n      play(options = {}) {\n        if (isPlaying || isRecording) {\n          throw new Error(\n            'CEREBRAL Recorder - You can not play while already playing or recording'\n          )\n        }\n\n        allowedSignals = options.allowedSignals || []\n        resetState()\n        isPlaying = true\n        started = Date.now()\n        lastEventTimestamp = currentRecording.start\n\n        controller.runSignal = (...args) => {\n          if (allowedSignals.indexOf(args[0]) >= 0) {\n            originalRunSignal.apply(controller, args)\n          }\n        }\n        controller.flush(true)\n        runNextEvent()\n        controller.emit('recorder:play', currentSeek, options)\n      },\n      record(options = {}) {\n        // If we are recording over the previous stuff, go back to start\n        if (currentRecording) {\n          currentSeek = 0\n          ended = null\n        }\n\n        const paths = options.initialState || ['']\n        const state = paths.map(function(path) {\n          const arrayPath = path ? path.split('.') : []\n\n          return {\n            path: arrayPath,\n            value: JSON.stringify(controller.getState(arrayPath)),\n          }\n        })\n\n        currentRecording = {\n          initialState: state,\n          start: Date.now(),\n          events: [],\n        }\n\n        controller.on('recorder:event', addExternalEvent)\n\n        isRecording = true\n        controller.emit('recorder:record', options)\n      },\n      stop() {\n        const wasPlaying = isPlaying\n        clearTimeout(nextEventTimeout)\n        isPlaying = false\n        isRecording = false\n        controller.runSignal = originalRunSignal\n        controller.off('recorder:event', addExternalEvent)\n\n        if (wasPlaying) {\n          return\n        }\n\n        currentRecording.end = Date.now()\n        currentEventIndex = 0\n        currentRecording.events.push({\n          type: 'flush',\n          timestamp: Date.now(),\n        })\n        controller.emit('recorder:stop')\n      },\n      pause() {\n        ended = Date.now()\n        currentSeek = ended - started\n        clearTimeout(nextEventTimeout)\n        isPlaying = false\n        controller.emit('recorder:pause', currentSeek)\n      },\n      getRecording() {\n        return currentRecording\n      },\n      getCurrentSeek() {\n        return currentSeek\n      },\n      loadRecording(recording) {\n        currentRecording = recording\n      },\n      isRecording() {\n        return isRecording\n      },\n    }\n  }\n\n  return function Recorder(context) {\n    context.recorder = provider = provider || createProvider(context)\n\n    if (context.recorder.isRecording()) {\n      context.state = mutationMethods.reduce((state, method) => {\n        const originMethod = state[method]\n\n        state[method] = (...args) => {\n          context.recorder.getRecording().events.push({\n            type: 'mutation',\n            method,\n            args: JSON.stringify(args),\n            timestamp: Date.now(),\n          })\n          originMethod.apply(null, args)\n        }\n\n        return state\n      }, context.state)\n    }\n\n    return context\n  }\n}\n"]}