{"version":3,"sources":["../../src/operators/set.js"],"names":["target","value","set","state","props","resolve","isTag","Error","resolvedValue","isCompute","Object","assign","Array","isArray","slice","type","path","result","parts","split","key","pop","targetObj","reduce","displayName","String"],"mappings":";;;;;;kBAEe,UAASA,MAAT,EAAiBC,KAAjB,EAAwB;AACrC,WAASC,GAAT,OAAwC;AAAA,QAAzBC,KAAyB,QAAzBA,KAAyB;AAAA,QAAlBC,KAAkB,QAAlBA,KAAkB;AAAA,QAAXC,OAAW,QAAXA,OAAW;;AACtC,QAAI,CAACA,QAAQC,KAAR,CAAcN,MAAd,EAAsB,OAAtB,EAA+B,OAA/B,CAAL,EAA8C;AAC5C,YAAM,IAAIO,KAAJ,CACJ,iFADI,CAAN;AAGD;;AAED,QAAIC,gBAAgBH,QAAQJ,KAAR,CAAcA,KAAd,CAApB;;AAEA,QAAI,CAACI,QAAQC,KAAR,CAAcL,KAAd,CAAD,IAAyB,CAACI,QAAQI,SAAR,CAAkBR,KAAlB,CAA1B,IAAsD,qBAASA,KAAT,CAA1D,EAA2E;AACzEO,sBAAgBE,OAAOC,MAAP,CAAc,EAAd,EAAkBH,aAAlB,CAAhB;AACD,KAFD,MAEO,IACL,CAACH,QAAQC,KAAR,CAAcL,KAAd,CAAD,IACA,CAACI,QAAQI,SAAR,CAAkBR,KAAlB,CADD,IAEAW,MAAMC,OAAN,CAAcZ,KAAd,CAHK,EAIL;AACAO,sBAAgBA,cAAcM,KAAd,EAAhB;AACD;;AAED,QAAId,OAAOe,IAAP,KAAgB,OAApB,EAA6B;AAC3BZ,YAAMD,GAAN,CAAUG,QAAQW,IAAR,CAAahB,MAAb,CAAV,EAAgCQ,aAAhC;AACD,KAFD,MAEO;AACL,UAAMS,SAASP,OAAOC,MAAP,CAAc,EAAd,EAAkBP,KAAlB,CAAf;AACA,UAAMc,QAAQb,QAAQW,IAAR,CAAahB,MAAb,EAAqBmB,KAArB,CAA2B,GAA3B,CAAd;AACA,UAAMC,MAAMF,MAAMG,GAAN,EAAZ;AACA,UAAMC,YAAYJ,MAAMK,MAAN,CAAa,UAACvB,MAAD,EAASoB,GAAT,EAAiB;AAC9C,eAAQpB,OAAOoB,GAAP,IAAcV,OAAOC,MAAP,CAAc,EAAd,EAAkBX,OAAOoB,GAAP,KAAe,EAAjC,CAAtB;AACD,OAFiB,EAEfH,MAFe,CAAlB;AAGAK,gBAAUF,GAAV,IAAiBZ,aAAjB;;AAEA,aAAOS,MAAP;AACD;AACF;;AAEDf,MAAIsB,WAAJ,qBAAkCC,OAAOzB,MAAP,CAAlC,UAAqDyB,OAAOxB,KAAP,CAArD;;AAEA,SAAOC,GAAP;AACD,C;;AAxCD","file":"set.js","sourcesContent":["import { isObject } from '../utils'\n\nexport default function(target, value) {\n  function set({ state, props, resolve }) {\n    if (!resolve.isTag(target, 'state', 'props')) {\n      throw new Error(\n        'Cerebral operator.set: You have to use the STATE or PROPS TAG as first argument'\n      )\n    }\n\n    let resolvedValue = resolve.value(value)\n\n    if (!resolve.isTag(value) && !resolve.isCompute(value) && isObject(value)) {\n      resolvedValue = Object.assign({}, resolvedValue)\n    } else if (\n      !resolve.isTag(value) &&\n      !resolve.isCompute(value) &&\n      Array.isArray(value)\n    ) {\n      resolvedValue = resolvedValue.slice()\n    }\n\n    if (target.type === 'state') {\n      state.set(resolve.path(target), resolvedValue)\n    } else {\n      const result = Object.assign({}, props)\n      const parts = resolve.path(target).split('.')\n      const key = parts.pop()\n      const targetObj = parts.reduce((target, key) => {\n        return (target[key] = Object.assign({}, target[key] || {}))\n      }, result)\n      targetObj[key] = resolvedValue\n\n      return result\n    }\n  }\n\n  set.displayName = `operator.set(${String(target)}, ${String(value)})`\n\n  return set\n}\n"]}