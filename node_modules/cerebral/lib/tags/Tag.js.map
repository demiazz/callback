{"version":3,"sources":["../../src/tags/Tag.js"],"names":["Tag","tag","options","strings","values","hasValue","undefined","type","concat","getNestedTags","getters","populatePath","getter","toUpperCase","getPath","extractValueWithPath","reduce","currentPaths","string","idx","valueTemplate","obj","path","split","currentValue","key","index","currentPath","getValue","pathToString","toString"],"mappings":"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","file":"Tag.js","sourcesContent":["import { Compute } from '../Compute'\nimport { throwError } from '../utils'\n\n/*\n  Creates tag for targetting things with a path in Cerebral\n*/\nexport default class Tag {\n  constructor(tag, options = {}, strings, values) {\n    options.hasValue = options.hasValue === undefined ? true : options.hasValue\n\n    this.type = tag\n    this.options = options\n    this.strings = strings\n    this.values = values\n  }\n  /*\n    Returns all tags, also nested to identify nested state dependencies\n    in components\n  */\n  getTags() {\n    return [this].concat(this.getNestedTags())\n  }\n  /*\n    Gets the path of the tag, where nested tags are evaluated\n  */\n  getPath(getters) {\n    if (!getters) {\n      throwError('You can not grab the path from a Tag without getters')\n    }\n\n    return this.populatePath(getters)\n  }\n  /*\n    Uses the path of the tag to look it up in related getter\n  */\n  getValue(getters) {\n    if (!getters) {\n      throwError('You can not grab a value from a Tag without getters')\n    }\n\n    if (this.options.hasValue) {\n      const getter = getters[this.type]\n      if (!getter) {\n        throwError(\n          `Tag of type ${this.type.toUpperCase()} can not be used in this context`\n        )\n      }\n      return typeof getter === 'function'\n        ? getter(this.getPath(getters))\n        : this.extractValueWithPath(getter, this.getPath(getters))\n    } else {\n      return this.getPath(getters)\n    }\n  }\n  /*\n    Grab nested tags from the tags current path\n  */\n  getNestedTags() {\n    return this.strings.reduce((currentPaths, string, idx) => {\n      const valueTemplate = this.values[idx]\n\n      if (valueTemplate instanceof Tag) {\n        return currentPaths.concat(valueTemplate)\n      }\n\n      return currentPaths\n    }, [])\n  }\n  /*\n    Extracts value from object using a path\n  */\n  extractValueWithPath(obj, path) {\n    return path.split('.').reduce((currentValue, key, index) => {\n      if (index > 0 && currentValue === undefined) {\n        throwError(\n          `A tag is extracting with path \"${path}\", but it is not valid`\n        )\n      }\n\n      return currentValue[key]\n    }, obj)\n  }\n  /*\n    Populates nested tags in the tags path\n  */\n  populatePath(getters) {\n    return this.strings.reduce((currentPath, string, idx) => {\n      const valueTemplate = this.values[idx]\n\n      if (valueTemplate instanceof Tag || valueTemplate instanceof Compute) {\n        return currentPath + string + valueTemplate.getValue(getters)\n      }\n\n      return currentPath + string + (valueTemplate || '')\n    }, '')\n  }\n  /*\n    Produces a string representation of the tag\n  */\n  toString() {\n    return this.type + '`' + this.pathToString() + '`'\n  }\n  /*\n    Produces a string representation of the path\n  */\n  pathToString() {\n    return this.strings.reduce((currentPath, string, idx) => {\n      const valueTemplate = this.values[idx]\n\n      if (valueTemplate instanceof Tag) {\n        return currentPath + string + '${' + valueTemplate.toString() + '}'\n      }\n\n      return currentPath + string + (valueTemplate || '')\n    }, '')\n  }\n}\n"]}