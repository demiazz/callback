'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Compute = require('../Compute');

var _utils = require('../utils');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
  Creates tag for targetting things with a path in Cerebral
*/
var Tag = function () {
  function Tag(tag) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var strings = arguments[2];
    var values = arguments[3];

    _classCallCheck(this, Tag);

    options.hasValue = options.hasValue === undefined ? true : options.hasValue;

    this.type = tag;
    this.options = options;
    this.strings = strings;
    this.values = values;
  }
  /*
    Returns all tags, also nested to identify nested state dependencies
    in components
  */


  _createClass(Tag, [{
    key: 'getTags',
    value: function getTags() {
      return [this].concat(this.getNestedTags());
    }
    /*
      Gets the path of the tag, where nested tags are evaluated
    */

  }, {
    key: 'getPath',
    value: function getPath(getters) {
      if (!getters) {
        (0, _utils.throwError)('You can not grab the path from a Tag without getters');
      }

      return this.populatePath(getters);
    }
    /*
      Uses the path of the tag to look it up in related getter
    */

  }, {
    key: 'getValue',
    value: function getValue(getters) {
      if (!getters) {
        (0, _utils.throwError)('You can not grab a value from a Tag without getters');
      }

      if (this.options.hasValue) {
        var getter = getters[this.type];
        if (!getter) {
          (0, _utils.throwError)('Tag of type ' + this.type.toUpperCase() + ' can not be used in this context');
        }
        return typeof getter === 'function' ? getter(this.getPath(getters)) : this.extractValueWithPath(getter, this.getPath(getters));
      } else {
        return this.getPath(getters);
      }
    }
    /*
      Grab nested tags from the tags current path
    */

  }, {
    key: 'getNestedTags',
    value: function getNestedTags() {
      var _this = this;

      return this.strings.reduce(function (currentPaths, string, idx) {
        var valueTemplate = _this.values[idx];

        if (valueTemplate instanceof Tag) {
          return currentPaths.concat(valueTemplate);
        }

        return currentPaths;
      }, []);
    }
    /*
      Extracts value from object using a path
    */

  }, {
    key: 'extractValueWithPath',
    value: function extractValueWithPath(obj, path) {
      return path.split('.').reduce(function (currentValue, key, index) {
        if (index > 0 && currentValue === undefined) {
          (0, _utils.throwError)('A tag is extracting with path "' + path + '", but it is not valid');
        }

        return currentValue[key];
      }, obj);
    }
    /*
      Populates nested tags in the tags path
    */

  }, {
    key: 'populatePath',
    value: function populatePath(getters) {
      var _this2 = this;

      return this.strings.reduce(function (currentPath, string, idx) {
        var valueTemplate = _this2.values[idx];

        if (valueTemplate instanceof Tag || valueTemplate instanceof _Compute.Compute) {
          return currentPath + string + valueTemplate.getValue(getters);
        }

        return currentPath + string + (valueTemplate || '');
      }, '');
    }
    /*
      Produces a string representation of the tag
    */

  }, {
    key: 'toString',
    value: function toString() {
      return this.type + '`' + this.pathToString() + '`';
    }
    /*
      Produces a string representation of the path
    */

  }, {
    key: 'pathToString',
    value: function pathToString() {
      var _this3 = this;

      return this.strings.reduce(function (currentPath, string, idx) {
        var valueTemplate = _this3.values[idx];

        if (valueTemplate instanceof Tag) {
          return currentPath + string + '${' + valueTemplate.toString() + '}';
        }

        return currentPath + string + (valueTemplate || '');
      }, '');
    }
  }]);

  return Tag;
}();

exports.default = Tag;
//# sourceMappingURL=Tag.js.map